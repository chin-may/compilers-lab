//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class Irgen<R> extends GJNoArguDepthFirst<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //	String[] typearr = {"int[]", "boolean","int", "ident"};
	ArrayList<String> curtypelist = new ArrayList<String>();
	Stack<ArrayList<String>> paramst = new Stack<ArrayList<String>>();
	int temp = 30;
	int clabel = 1;
	int lastExpLoc;
	int formalParamNum;
	
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            Node tmp = e.nextElement();
            tmp.accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() )
         return n.node.accept(this);
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public R visit(Goal n) {
	  
	  current = top;
	  
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> "public"
    * f4 -> "static"
    * f5 -> "void"
    * f6 -> "main"
    * f7 -> "("
    * f8 -> "String"
    * f9 -> "["
    * f10 -> "]"
    * f11 -> Identifier()
    * f12 -> ")"
    * f13 -> "{"
    * f14 -> PrintStatement()
    * f15 -> "}"
    * f16 -> "}"
    */
   public R visit(MainClass n) {
      
      ClassData mn = top.classes.get(n.f1.f0.tokenImage);
      curcl = mn;
      current = mn;
      
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      n.f13.accept(this);
      n.f14.accept(this);
      n.f15.accept(this);
      n.f16.accept(this);
      current = top;
      return (R) mn;
   }

   /**
    * f0 -> ClassDeclaration()
    *       | ClassExtendsDeclaration()
    */
   public R visit(TypeDeclaration n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( VarDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public R visit(ClassDeclaration n) {
      current = top.classes.get(n.f1.f0.tokenImage);
      curcl = (ClassData) current;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      current = top;
      return null;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( VarDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public R visit(ClassExtendsDeclaration n) {
      R _ret=null;
      //Dont know why I did this, horrible idea!
     /* ClassData cd = new ClassData();
      cd.name = n.f1.f0.tokenImage;
      cd.parent = top.lookup(n.f1.f0.tokenImage);
      if(cd.parent==null){
    	  System.out.print("Non existant class extended");
    	  System.exit(1);
      }
      current = cd;
      top.classes.put(cd.name, cd);*/
      ClassData cd = top.classes.get(n.f1.f0.tokenImage);
      current = cd;
      curcl = cd;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      current = top;
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public R visit(VarDeclaration n) {
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      VarData v;
      if(current instanceof FuncData){
    	  ((FuncData)current).vars.get(n.f1.f0.tokenImage).varloc = temp++;
      }
/*	  if(current instanceof ClassData){
		  v = ((ClassData) current).attr.get(n.f1.f0.tokenImage);
		  if(curcl.parent!=null && curcl.parent instanceof ClassData){
			  VarData tempva = (VarData)curcl.parent.lookup(n.f1.f0.tokenImage);
			  if(tempva!=null && !top.isParent(tempva.type, v.type)){
				  System.out.print("Override type error");
			  }
		  }
	  }
	  v = (VarData)current.lookup(n.f1.f0.tokenImage);
	  if(!top.classes.containsKey(v.type)){
		  if(!(v.type.equals("int") || v.type.equals("int[]") ||v.type.equals("boolean"))){
			  System.out.print("Variable declared of nonexistant type");
		  }
			  
	  }*/
      return null;
   }

   /**
    * f0 -> "public"
    * f1 -> Type()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> Expression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public R visit(MethodDeclaration n) {
	  FuncData fd;
	  fd = ((ClassData) current).meth.get(n.f2.f0.tokenImage);
/*	  if(curcl.parent!=null && curcl.parent instanceof ClassData){
		  FuncData tempfd = ((ClassData)curcl.parent).flookup(n.f2.f0.tokenImage);
		  if(tempfd!=null){
			  if(!top.isParent(tempfd.ret,fd.ret)){
				  System.out.print("Override type error");
			  }
			  for(int i=0;i<fd.paramlist.size();i++){
				  if(!top.isParent(tempfd.paramlist.get(i), fd.paramlist.get(i))){
					  System.out.print("Override type error");
				  }
			  }
		  }
	  }*/
	  fd = curcl.flookup(n.f2.f0.tokenImage);
	  current = fd;
/*	  if(!top.classes.containsKey(fd.ret)){
		  if(!(fd.ret.equals("int") || fd.ret.equals("int[]") ||fd.ret.equals("boolean"))){
			  System.out.print("Return declared of nonexistant type");
		  }
	  }
	  
	  for(int i=0;i<fd.paramlist.size();i++){
		  String tparam = fd.paramlist.get(i);
		  if(!(top.classes.containsKey(tparam)||tparam.equals("int")||tparam.equals("int[]")||tparam.equals("boolean"))){
			  System.out.print("Parameter declared of nonexistant type");
			  
		  }
	  }
	 
*/	
	  int ct1 = temp++;
	  formalParamNum = 0;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
	  gen(curcl.name + "_" + n.f2.f0.tokenImage + " [ " + formalParamNum + " ] ");
	  gen("\nBEGIN ");
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      gen("RETURN ");
      n.f10.accept(this);
      gen("\nEND ");
      n.f11.accept(this);
      n.f12.accept(this);
      current = curcl;
      return null;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public R visit(FormalParameterList n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public R visit(FormalParameter n) {
	  formalParamNum++;
	  ((FuncData)current).vars.get(n.f1.f0.tokenImage).varloc = formalParamNum;
      n.f0.accept(this);
      n.f1.accept(this);
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public R visit(FormalParameterRest n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> ArrayType()
    *       | BooleanType()
    *       | IntegerType()
    *       | Identifier()
    */
   public R visit(Type n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "int"
    * f1 -> "["
    * f2 -> "]"
    */
   public R visit(ArrayType n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "boolean"
    */
   public R visit(BooleanType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "int"
    */
   public R visit(IntegerType n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Block()
    *       | AssignmentStatement()
    *       | ArrayAssignmentStatement()
    *       | IfStatement()
    *       | WhileStatement()
    *       | PrintStatement()
    */
   public R visit(Statement n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public R visit(Block n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */
   //TODO
   public R visit(AssignmentStatement n) {
/*      String temp = (String)n.f0.accept(this);
      String lexp;
      if(((FuncData)current).vars.containsKey(temp)){
	       lexp = ((FuncData)current).vars.get(temp).type;
      }
      else{
    	   lexp = ((VarData)curcl.lookup(temp)).type;
      }
      n.f1.accept(this);
      String rexp = (String)n.f2.accept(this);
      if(!top.isParent(lexp, rexp)){
    	  System.out.print("Assignment error");
      }*/
	  if(((FuncData)current).vars.containsKey(n.f0.f0.tokenImage)){
		  gen("MOVE TEMP " + ((FuncData)current).vars.get(n.f0.f0.tokenImage).varloc + " ");
	      n.f0.accept(this);
	      n.f1.accept(this);
	      n.f2.accept(this);
	  }
	  else{
		  gen("hstore temp 0 " + (1 + curcl.getAttrNum(n.f0.f0.tokenImage))*4 );
	      n.f0.accept(this);
	      n.f1.accept(this);
	      n.f2.accept(this);
	  }
      n.f3.accept(this);
      return null;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "["
    * f2 -> Expression()
    * f3 -> "]"
    * f4 -> "="
    * f5 -> Expression()
    * f6 -> ";"
    */
   public R visit(ArrayAssignmentStatement n) {
      R _ret=null;
      assert(current instanceof ClassData);
      gen("HSTORE PLUS TEMP " + ((FuncData)current).vars.get(n.f0.f0.tokenImage).varloc + " ");
      gen("TIMES 4 PLUS 1 ");
      n.f1.accept(this);
      n.f2.accept(this);
      gen(" 0 ");
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
/*      String lexp = (String)n.f0.accept(this);
      VarData v = (VarData) ((FuncData)current).lookup(lexp);
      if(!v.type.equals("int[]")){
    	  System.out.print("Non array indexed");
    	  System.exit(1);
      }
      
      n.f1.accept(this);
      n.f2.accept(this);
      if(!n.f2.accept(this).equals("int")){
    	  System.out.print("Non integer index used");
    	  System.exit(1);
      }
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      if(!n.f5.accept(this).equals("int")){
    	  System.out.print("Non integer array assignment");
    	  System.exit(1);
      }*/
      n.f6.accept(this);
      return _ret;
   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public R visit(IfStatement n) {
	  int l1 = clabel++; //else label
	  int l2 = clabel++; //end label
      n.f0.accept(this);
      n.f1.accept(this);
/*      if( !n.f2.accept(this).equals("boolean")){
    	  System.out.print("non boolean if");
      }*/
      gen("CJUMP ");
      n.f2.accept(this);
      gen("L" + l1 + " ");
      n.f3.accept(this);
      n.f4.accept(this);
      gen("JUMP L" + l2 + " ");
      gen("L" + l1 + " NOOP ");
      n.f5.accept(this);
      n.f6.accept(this);
      gen("L" + l2 + " NOOP ");
      return null;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public R visit(WhileStatement n) {
	  int l1 = clabel++; //start label
	  int l2 = clabel++;// end label
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
/*      if( !n.f2.accept(this).equals("boolean")){
    	  System.out.print("non boolean while");
      }*/
      gen("L" + l1 + "CJUMP " );
      n.f2.accept(this);
      gen("L" + l2);
      
      n.f3.accept(this);
      n.f4.accept(this);
      gen("JUMP L" + l1 + " L" + l2 +" NOOP ");
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> Expression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public R visit(PrintStatement n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      gen("PRINT ");
      String ptemp =  (String)n.f2.accept(this);
/*      if(!ptemp.equals("int")){
    	  System.out.print("print statement error");
      }*/
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> AndExpression()
    *       | CompareExpression()
    *       | PlusExpression()
    *       | MinusExpression()
    *       | TimesExpression()
    *       | ArrayLookup()
    *       | ArrayLength()
    *       | MessageSend()
    *       | PrimaryExpression()
    */
   public R visit(Expression n) {
      return n.f0.accept(this);
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "&"
    * f2 -> PrimaryExpression()
    */
   public R visit(AndExpression n) {
	  int l1 = clabel++; //false label
	  int l2 = clabel++; //end label
	  int ct1 = temp++;
	  gen("BEGIN CJUMP ");
      String lexp = (String) n.f0.accept(this);
      gen("L" + l1);
      n.f1.accept(this);
      gen("CJUMP ");
      String rexp = (String)n.f2.accept(this);
      gen("L" + l1);
      gen("MOVE TEMP " + ct1 + " 1 ");
      gen("JUMP L" + l2);
      gen("L" + l1 );
      gen("MOVE TEMP " + ct1 + " 0 ");
      gen("L" + l2 + "NOOP");
      gen("\nRETURN TEMP " +ct1 + " END ");
/*      if(! (lexp.equals("boolean")&& (rexp.equals("boolean")))){
    	  System.out.print("AndExpression Error");
    	  System.exit(1);
      }*/
      return (R) "boolean";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "<"
    * f2 -> PrimaryExpression()
    */
   public R visit(CompareExpression n) {
	  gen("LT ");
      String lexp = (String)n.f0.accept(this);
      gen(" ");
      n.f1.accept(this);
      String rexp = (String)n.f2.accept(this);
/*      if(! (lexp.equals("int")&& (rexp.equals("int")))){
    	  System.out.print("CompareExpression Error");
    	  System.exit(1);
      }*/
      return (R) "boolean";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "+"
    * f2 -> PrimaryExpression()
    */
   public R visit(PlusExpression n) {
	  gen("PLUS ");
      String lexp = (String)n.f0.accept(this);
      gen(" ");
      n.f1.accept(this);
      String rexp = (String)n.f2.accept(this);
/*      if(! (lexp.equals("int")&& (rexp.equals("int")))){
    	  System.out.print("PlusExpression Error");
    	  System.exit(1);
      }*/
      return (R) "int";
      
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "-"
    * f2 -> PrimaryExpression()
    */
   public R visit(MinusExpression n) {
	  gen("MINUS ");
      String lexp = (String)n.f0.accept(this);
      gen(" ");
      n.f1.accept(this);
      String rexp = (String)n.f2.accept(this);
/*      if(! (lexp.equals("int")&& (rexp.equals("int")))){
    	  System.out.print("MinusExpression Error");
    	  System.exit(1);
      }*/
      return (R) "int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "*"
    * f2 -> PrimaryExpression()
    */
   public R visit(TimesExpression n) {
	  gen("TIMES ");
      String lexp = (String)n.f0.accept(this);
      gen(" ");
      n.f1.accept(this);
      String rexp = (String)n.f2.accept(this);
/*      if(! (lexp.equals("int")&& (rexp.equals("int")))){
    	  System.out.print("TimesExpression Error");
    	  System.exit(1);
      }*/
      return (R) "int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "["
    * f2 -> PrimaryExpression()
    * f3 -> "]"
    */
   public R visit(ArrayLookup n) {
	  int ct1 = temp++;
	  gen("BEGIN HLOAD TEMP " + ct1 + " PLUS ");
      String lexp = (String)n.f0.accept(this);
      //VarData v = (VarData) ((FuncData)current).lookup(lexp);
/*      if(!lexp.equals("int[]")){
    	  System.out.print("Non array indexed");
    	  System.exit(1);
      }*/
      
      n.f1.accept(this);
      gen("TIMES 4 PLUS 1");
      n.f2.accept(this);
      gen("0 \nRETURN TEMP " + ct1 + "\nEND ");
/*      if(!n.f2.accept(this).equals("int")){
    	  System.out.print("Non integer index used");
    	  System.exit(1);
      }*/
      n.f3.accept(this);
      return (R) "int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> "length"
    */
   public R visit(ArrayLength n) {
	  int ct1;
      ct1 = temp++;
	  gen("BEGIN HLOAD TEMP " + ct1 );
      String lexp = (String)n.f0.accept(this);
      n.f1.accept(this);
      gen(" 0 \nRETURN TEMP " +ct1 + " END ");
      n.f2.accept(this);
      //VarData v = (VarData) ((FuncData)current).lookup(lexp);
/*      if(!lexp.equals("int[]")){
    	  System.out.print("Non array length called");
    	  System.exit(1);
      }*/
      return (R) "int";
   }

   /**
    * f0 -> PrimaryExpression()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ExpressionList() )?
    * f5 -> ")"
    */
   public R visit(MessageSend n) {
	   paramst.push(curtypelist);
      curtypelist = new ArrayList<String>();
	  int ct1;
	  ct1 =temp++;
	  int ct2 = temp++;
	  int ct3 = temp++;
      gen("CALL BEGIN move TEMP " + ct3);
      String instancetype = (String) n.f0.accept(this);
	  ClassData cd = (ClassData)(top.classes.get(instancetype));
/*      if(!cd.meth.containsKey(n.f2.f0.tokenImage)){
    	  System.out.print("Method not found");
    	  System.exit(1);
      }*/
	  int funnum = -1;
	  for(int j=0; j<cd.allfun.size(); j++){
		  if(cd.allfun.get(j).equals(n.f2.f0.tokenImage)) funnum = j ;
	  }
	  assert(funnum >= 0);
      n.f1.accept(this);
      n.f2.accept(this);
      gen("hload temp " + ct1 + " temp " + ct3 + " 0 ");
      gen("hload temp " + ct2 + " TEMP " + ct1 + " " + 4*funnum);
      gen("return temp " + ct2 + " \nend ( temp " + ct3 + " ");
//	  gen(String.format("%d  \nRETURN TEMP %d END ( ",  4 + 4*funnum, ct1 ));
      n.f3.accept(this);
      n.f4.accept(this);
      gen(" ) ");
      n.f5.accept(this);
      FuncData fd = cd.flookup(n.f2.f0.tokenImage);
/*      if(curtypelist.size()!=fd.paramlist.size())
    	  System.out.print("Param list length error");
      boolean paramflag = true;
      for(int i=0;i<curtypelist.size();i++){
    	  if(!top.isParent(fd.paramlist.get(i), curtypelist.get(i)))
    			  paramflag = false;
      }
      if(!paramflag)
    	  System.out.print("Parameter error");*/
      curtypelist = paramst.pop();
      return (R)fd.ret;
   }

   /**
    * f0 -> Expression()
    * f1 -> ( ExpressionRest() )*
    */
   public R visit(ExpressionList n) {
	  curtypelist.add((String)n.f0.accept(this));
      n.f1.accept(this);
      return null;
   }

   /**
    * f0 -> ","
    * f1 -> Expression()
    */
   public R visit(ExpressionRest n) {
	  curtypelist.add((String)n.f1.accept(this));
      n.f0.accept(this);
      n.f1.accept(this);
      return null;
   }

   /**
    * f0 -> IntegerLiteral()
    *       | TrueLiteral()
    *       | FalseLiteral()
    *       | Identifier()
    *       | ThisExpression()
    *       | ArrayAllocationExpression()
    *       | AllocationExpression()
    *       | NotExpression()
    *       | BracketExpression()
    */
   public R visit(PrimaryExpression n) {
      R _ret=null;
      R tempr = n.f0.accept(this);
      
      String[] primExpAr = {"int", "boolean","boolean", "id","this", "arrayalloc","not","brac"};
      switch(n.f0.which){
      case 0:
    	  return (R) "int";
      case 1:
    	  return (R) "boolean";
      case 2:
    	  return (R) "boolean";
      case 3:
    	  if(((FuncData)current).vars.containsKey((String)tempr)){
    		  VarData t = ((FuncData)current).vars.get((String)tempr);
	    	  assert(t!=null);
	    	  gen("TEMP " + t.varloc + " ");
	    	  return (R) t.type;
    	  }
    	  else if(curcl.allatt.contains((String)tempr)){
    		  int ct1 = temp++;
    		  gen("begin hload temp "+ ct1 +" temp 0 " + (1+curcl.getAttrNum((String)tempr))*4 + " return temp " + ct1 + " end ");
    		  return (R) ((VarData)curcl.lookup((String)tempr)).type;
    	  }
    	  else assert(false);
      case 4:
    	  return (R) (curcl.name);
      case 5:
    	  return (R)"int[]";
      case 6:
    	  return (R) tempr;
      case 7:
    	  return (R) "boolean";
      case 8:
    	  return (R) tempr;
	  default:
    	  return null;
      }
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      gen(n.f0.tokenImage + " ");
      return _ret;
   }

   /**
    * f0 -> "true"
    */
   public R visit(TrueLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      gen("1 ");
      return _ret;
   }

   /**
    * f0 -> "false"
    */
   public R visit(FalseLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      gen("0 ");
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Identifier n) {
      n.f0.accept(this);
      return (R) n.f0.tokenImage;
   }

   /**
    * f0 -> "this"
    */
   public R visit(ThisExpression n) {
      R _ret=null;
      n.f0.accept(this);
      gen("TEMP 0 ");
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> "int"
    * f2 -> "["
    * f3 -> Expression()
    * f4 -> "]"
    */
   public R visit(ArrayAllocationExpression n) {
      R _ret=null;
      int ct1,ct2;
      ct1 = temp++;
      ct2 = temp++;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      gen("BEGIN MOVE TEMP " + ct2 + " ");
      n.f3.accept(this);
      gen("MOVE TEMP " + ct1 + " HALLOCATE TIMES 4 PLUS 1 TEMP " + ct2);
      gen("HSTORE TEMP " + ct1 + " 0 " + " TEMP " + ct2);
      gen("RETURN TEMP " + ct1 + " END");
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public R visit(AllocationExpression n) {
      n.f0.accept(this);
      n.f1.accept(this);
      int ct1 = temp++;
      int ct2 = temp++;
      int i = 0;
      ClassData cd = top.classes.get(n.f1.f0.tokenImage);
/*      gen("BEGIN \n MOVE TEMP " +ct1 +" HALLOCATE " + (cd.allatt.size() + cd.allfun.size() + 1) * 4 );
      gen("HSTORE TEMP " + ct1 + " 0 " + cd.allfun.size());
      for(FuncData f:cd.meth.values()){
    	  gen("HSTORE TEMP " + ct1 + " " + (1 + i++) * 4 + " " + cd.getClassName(f.name) + "_" + f.name + " ");
      }
      gen("RETURN TEMP " + ct1 + "\n END ");
      */
      gen("BEGIN \n MOVE TEMP " + ct1 + " HALLOCATE" + (cd.allatt.size() + 1) * 4 + " ");
      gen("\nMOVE TEMP " + ct2 + " HALLOCATE " + cd.allfun.size()*4 + " ");
      for(FuncData f:cd.meth.values()){
    	  gen("HSTORE TEMP " + ct2 + " " + i++ * 4 + " " + cd.getClassName(f.name) + "_" + f.name + " \n");
      }
      gen("hstore temp " + ct1 + " 0 temp " + ct2 + " ");
      gen("RETURN TEMP " + ct1 + "\n END ");
      
      n.f2.accept(this);
      n.f3.accept(this);
      return (R) n.f1.f0.tokenImage;
   }

   /**
    * f0 -> "!"
    * f1 -> Expression()
    */
   public R visit(NotExpression n) {
      R _ret=null;
      n.f0.accept(this);
      gen("MINUS 1");
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> "("
    * f1 -> Expression()
    * f2 -> ")"
    */
   public R visit(BracketExpression n) {
      n.f0.accept(this);
      n.f2.accept(this);
      return (R)n.f1.accept(this);
   }

   void gen(String s){
	   System.out.print(s.toUpperCase());
   }

}
