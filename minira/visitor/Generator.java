//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;

import java.awt.font.NumericShaper.Range;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class Generator<R> extends GJNoArguDepthFirst<R> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
	
	ProcData currproc;
	String[] regStr = {" t0 ",  " t1 ", " t2 ", " t3 ", " t4 " , " t5 ", " t6 ", " t7 ", " t8 ", " t9 ", 
    " s0 ", " s1 ", " s2 ", " s3 ", " s4 ", " s5 ", " s6 ", " s7 ", " v0 ", " v1 ", " a0 ", " a1 ", " a2 ", " a3 "};
	String[] opStr = {" lt ", " plus ", " minus ", " times "};
	int currloc = 0;
	int currstack = 0;
	
	int exploc = -1;
	
   public R visit(NodeList n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n) {
      if ( n.present() ){
    	  if(n.node instanceof Label){
    		  emit(((Label)n.node).f0.tokenImage);
    	  }
         return n.node.accept(this);
         }
      else
         return null;
   }

   public R visit(NodeSequence n) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n) {
	  currproc = procs.get("MAIN");
	  currstack = currproc.stacktop;
	  currloc = 0;
	  emit("MAIN" + " [  0  ] [" + currproc.stackspace + "] ["+ currproc.maxcall + " ]\n" );
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      emit("end");
      emit("\n");
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n) {
	  currproc = procs.get(n.f0.f0.tokenImage);
	  currstack = currproc.stacktop;
	  currloc = 0;
	  emit(n.f0.f0.tokenImage + " [ " + n.f2.f0.tokenImage + "] [" + currproc.stackspace + "] ["+ currproc.maxcall + " ]\n" );
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n) {
      R _ret=null;
      n.f0.accept(this);
      currloc++;
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n) {
	   emit("noop\n");
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n) {
	   emit("error");
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n) {
      R _ret=null;
      int tnum = Integer.parseInt(n.f1.f1.f0.tokenImage);
      RangePair var = currproc.ranges.get(tnum);
      if(var.isReg){
    	  emit("cjump " + regStr[var.location] + n.f2.f0.tokenImage);
      }
      else{
    	  emit("aload v0 spilledarg " + var.location + "\n");
    	  emit("cjump v0 " + n.f2.f0.tokenImage + "\n");
      }
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n) {
      R _ret=null;
      emit("jump " + n.f1.f0.tokenImage + "\n");
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n) {
      R _ret=null;
      RangePair var1, var2;
      var1 = currproc.ranges.get(Integer.parseInt(n.f1.f1.f0.tokenImage));
      var2 = currproc.ranges.get(Integer.parseInt(n.f3.f1.f0.tokenImage));
      if(var1.isReg && var2.isReg ){
    	  emit("hstore " + regStr[var1.location] + n.f2.f0.tokenImage + regStr[var2.location] + "\n");
      }
      else if(var1.isReg && !var2.isReg){
    	  emit("aload v0 spilledarg " + var2.location + "\n");
    	  emit("hstore " + regStr[var1.location] + n.f2.f0.tokenImage + " v0\n");
      }
      else if(!var1.isReg && var2.isReg){
    	  emit("aload v0 spilledarg " + var1.location + "\n");
    	  emit("hstore v0 " + n.f2.f0.tokenImage + regStr[var2.location]  + "\n");
      }
      else{
    	  emit("aload v0 spilledarg " + var1.location + "\n");
    	  emit("aload v1 spilledarg " + var2.location + "\n");
    	  emit("hstore v0 " + n.f2.f0.tokenImage + " v1\n");
      }
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n) {
      R _ret=null;
      RangePair var1, var2;
      var1 = currproc.ranges.get(Integer.parseInt(n.f1.f1.f0.tokenImage));
      var2 = currproc.ranges.get(Integer.parseInt(n.f2.f1.f0.tokenImage));
      if(var1.isReg && var2.isReg ){
    	  emit("hload " + regStr[var1.location] + regStr[var2.location] + n.f3.f0.tokenImage + "\n");
      }
      else if(var1.isReg && !var2.isReg){
    	  emit("aload v0 spilledarg " + var2.location + "\n");
    	  emit("hload " + regStr[var1.location] + " v0 "+ n.f3.f0.tokenImage + "\n" );
      }
      else if(!var1.isReg && var2.isReg){
    	  emit("aload v0 spilledarg " + var1.location + "\n");
    	  emit("hload v0 " + regStr[var2.location] +  n.f3.f0.tokenImage + "\n");
      }
      else{
    	  emit("aload v0 spilledarg " + var1.location + "\n");
    	  emit("aload v1 spilledarg " + var2.location + "\n");
    	  emit("hload v0 v1 " + n.f3.f0.tokenImage + "\n" );
      }
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n) {
	  exploc = Integer.parseInt(n.f1.f1.f0.tokenImage);
	  if(!currproc.ranges.containsKey(exploc)){
		  //For handling cases where Temp is not in any live out and is used only on that line
		  exploc = -2;
		  RangePair rp = new RangePair(-2,0,0);
		  rp.isReg = true;
		  rp.location = 18;
		  currproc.ranges.put(-2, rp);
	  }
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      exploc = -1;
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n) {
      R _ret=null;
      n.f0.accept(this);
      
      SimpleExp sim = n.f1;
      
      switch(sim.f0.which){
      case 0:
    	  Temp tm = (Temp)sim.f0.choice;
    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    	  if(var.isReg){
    		  emit("print " + regStr[var.location]);
    	  }
    	  else{
    		  emit("aload v0 spilledarg " + var.location);
    		  emit("print v0");
    	  }
    	  break;
      case 1:
    	  emit("print " + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
      }
      
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n) {
	   
	   return n.f0.accept(this);
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n) {
      R _ret=null;
      for(int i = 10; i<= 17; i++){
    	  if(currproc.usedReg.contains(i))
    		  emit("astore spilledarg " + currstack++ + regStr[i]);
      }
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f4.accept(this);
      
      SimpleExp sim = n.f3;
      switch(sim.f0.which){
      case 0:
    	  Temp tm = (Temp) sim.f0.choice;
    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    	  if(var.isReg){
    		  emit("move v0 " + regStr[var.location]);
    	  }
    	  else{
    		  emit("aload v0 spilledarg " + var.location);
    	  }
    	  break;
      case 1:
    	  emit("move v0 " + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
      }
      
      for(int i = 17; i>= 10; i--){
    	  if(currproc.usedReg.contains(i))
    		  emit("aload " + regStr[i] + " spilledarg " + --currstack);
      }
      emit("end");
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n) {
      R _ret=null;
      StmNode st = currproc.nodes.get(currloc);
      Stack<RangePair> tmpstack = new Stack<>();
      //TODO only caller saved register should be saved here
      for(Integer ot:st.lout){
    	  RangePair var = currproc.ranges.get(ot);
    	  if(var.isReg && var.location > 10){
    		  emit("astore spilledarg " + currstack + regStr[var.location] + "\n");
    		  tmpstack.push(var);
    		  currstack++;
    	  }
      }
      emit("astore spilledarg " + currstack++ + " a0 ");
      emit("astore spilledarg " + currstack++ + " a1 ");
      emit("astore spilledarg " + currstack++ + " a2 ");
      emit("astore spilledarg " + currstack++ + " a3 ");
      n.f0.accept(this);
      n.f2.accept(this);
      n.f4.accept(this);
      int paramnum = 0;
      for(Node nod:n.f3.nodes){
    	  Temp tm = (Temp) nod;
    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    	  if(paramnum <= 3){
    		  if(var.isReg){
    			  emit("move "  + "a" + paramnum + regStr[var.location]);
    		  }
    		  else{
    			  emit("aload a" + paramnum + " spilledarg " + var.location);
    		  }
    	  }
    	  else{
    		  if(var.isReg){
    			  emit("passarg " + (paramnum - 3) + regStr[var.location] + "\n");
    		  }
    		  else{
    			  emit("aload v1 spilledarg " + var.location + "\n");
    			  emit("passarg " + (paramnum - 3) + " v1\n");
    		  }
    	  }
    	  paramnum++;
      }
      
      SimpleExp sim = n.f1;
      Temp tm;
      //The actual call
      if(sim.f0.choice instanceof Temp){
    	  tm = (Temp) sim.f0.choice;
    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    	  if(var.isReg){
    		  emit("call " + regStr[var.location]);
    	  }
    	  else{
    		  emit("aload v0 spilledarg " + var.location);
    		  emit("call v0");
    	  }
      }
      else{
    	  System.out.println("xxxxx function call");
      }
      
      emit("aload a3 spilledarg " + --currstack );
      emit("aload a2 spilledarg " + --currstack );
      emit("aload a1 spilledarg " + --currstack );
      emit("aload a0 spilledarg " + --currstack );
      while(!tmpstack.empty()){
    	  RangePair var = tmpstack.pop();
    	  emit("aload " + regStr[var.location] + " spilledarg "+ --currstack + "\n");
      }
      RangePair retvar = currproc.ranges.get(exploc);
      if(retvar.isReg){
    	  emit("move " + regStr[retvar.location] + "v0");
      }
      else{
    	  emit("astore spilledarg " + retvar.location + " v0");
      }
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n) {
      n.f0.accept(this);
      RangePair destvar = currproc.ranges.get(exploc);
      SimpleExp sim = n.f1;
      
      if(destvar.isReg){
	      switch(sim.f0.which){
	      case 0:
	    	  Temp tm = (Temp) sim.f0.choice;
	    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
	    	  if(var.isReg){
	    		  emit("move " + regStr[destvar.location] + " hallocate " + regStr[var.location]);
	    	  }
	    	  else{
	    		  emit("aload v0 spilledarg " + var.location + "\n");
	    		  emit("move " + regStr[destvar.location] + " hallocate v0 ");
	    	  }
	    	  break;
	      case 1:
	    	  IntegerLiteral il = (IntegerLiteral) sim.f0.choice;
	    	  emit("move  "+ regStr[destvar.location] + " hallocate " + il.f0.tokenImage);
	    	  break;
	      }
    	  
      }
      else{
    	  switch(sim.f0.which){
    	  case 0:
	    	  Temp tm = (Temp) sim.f0.choice;
	    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
	    	  if(var.isReg){
	    		  emit("move v0 hallocate " + regStr[var.location]);
	    		  emit("astore spilledarg " + destvar.location + " v0 ");
	    	  }
	    	  else{
	    		  emit("aload v0 spilledarg " + var.location);
	    		  emit("move v0 hallocate v0");
	    		  emit("astore spilledarg " + destvar.location + " v0");
	    	  }
    	  case 1:
	    	  IntegerLiteral il = (IntegerLiteral) sim.f0.choice;
	    	  emit("move v0 hallocate " + il.f0.tokenImage);
	    	  emit("astore spilledarg " + destvar.location + " v0");
    	  }
      }
      
      
      return (R) (Integer)18;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      
      SimpleExp sim = n.f2;
      RangePair destvar = currproc.ranges.get(exploc) ;
      RangePair lvar = currproc.ranges.get(Integer.parseInt(n.f1.f1.f0.tokenImage));
      if(destvar.isReg && lvar.isReg){
    	  switch(sim.f0.which){
    	  case 0:
    		  Temp tm = (Temp) sim.f0.choice;
    		  RangePair rvar = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    		  if(rvar.isReg)
    			  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + regStr[lvar.location] + regStr[rvar.location]);
    		  else{
    			  emit("aload v0 spilledarg " + rvar.location);
    			  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + regStr[lvar.location] + " v0");
    		  }
    		  break;
    	  case 1:
    		  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + regStr[lvar.location] + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
    	  }
      }
      else if(destvar.isReg && !lvar.isReg){
    	  switch(sim.f0.which){
    	  case 0:
    		  Temp tm = (Temp) sim.f0.choice;
    		  RangePair rvar = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    		  if(rvar.isReg){
    			  emit("aload v0 spilledarg " + lvar.location);
    			  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + " v0 " + regStr[rvar.location]);
    		  }
    		  else{
    			  emit("aload v0 spilledarg " + lvar.location);
    			  emit("aload v1 spilledarg " + rvar.location);
    			  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + " v0 v1 ");
    		  }
    		  break;
    	  case 1:
    		  emit("aload v0 spilledarg " + lvar.location);
    		  emit("move " + regStr[destvar.location] + opStr[n.f0.f0.which] + " v0 " + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
    	  }
    	  
      }
      
      else if(!destvar.isReg && lvar.isReg){
    	  switch(sim.f0.which){
    	  case 0:
    		  Temp tm = (Temp) sim.f0.choice;
    		  RangePair rvar = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    		  if(rvar.isReg){
    			  emit("move v0 " +  opStr[n.f0.f0.which] + regStr[lvar.location] + regStr[rvar.location]);
    			  emit("astore spilledarg " + destvar.location + " v0 ");
    		  }
    		  else{
    			  emit("aload v0 spilledarg " + rvar.location);
    			  emit("move v0 " + opStr[n.f0.f0.which] + regStr[lvar.location] + " v0 ");
    			  emit("astore spilledarg " + destvar.location + " v0 ");
    		  }
    		  break;
    	  case 1:
    		  emit("move v0" + opStr[n.f0.f0.which] + regStr[lvar.location] + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
    		  emit("astore spilledarg " + destvar.location + " v0 ");
    	  }
    	  
      }
     
      //lvar is not reg, destvar is not reg
      else{
    	  switch(sim.f0.which){
    	  case 0:
    		  Temp tm = (Temp) sim.f0.choice;
    		  RangePair rvar = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
    		  if(rvar.isReg){
    			  emit("aload v0 spilledarg " + lvar.location);
    			  emit("move v0 " + opStr[n.f0.f0.which] + " v0 " + regStr[rvar.location]);
	    		  emit("astore spilledarg " + destvar.location + " v0 ");
    		  }
    		  else{
    			  emit("aload v0 spilledarg " + lvar.location);
    			  emit("aload v1 spilledarg " + rvar.location);
    			  emit("move v0" +  opStr[n.f0.f0.which] + " v0 v1 ");
	    		  emit("astore spilledarg " + destvar.location + " v0 ");
    		  }
    		  break;
    	  case 1:
    		  emit("aload v0 spilledarg " + lvar.location);
    		  emit("move v0" +  opStr[n.f0.f0.which] + " v0 " + ((IntegerLiteral)sim.f0.choice).f0.tokenImage);
    		  emit("astore spilledarg " + destvar.location + " v0 ");
    	  }
    	  
      }
      
      return null;
   }

   /**
    * f0 -> "LT"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    */
   public R visit(Operator n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n) {
	   //Should be visited only in the case movestmt -> Exp -> SimpleExp
      RangePair destvar = currproc.ranges.get(exploc);
      
      if(destvar.isReg){
	      switch(n.f0.which){
	      case 0:
	    	  Temp tm = (Temp) n.f0.choice;
	    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
	    	  if(var.isReg){
	    		  emit("move " + regStr[destvar.location] + regStr[var.location]);
	    	  }
	    	  else{
	    		  emit("aload " +regStr[destvar.location]+  " spilledarg " + var.location + "\n");
	    	  }
	    	  break;
	      case 1:
	    	  IntegerLiteral il = (IntegerLiteral) n.f0.choice;
	    	  emit("move  "+ regStr[destvar.location] + il.f0.tokenImage);
	    	  break;
	      case 2:
	    	  emit("move "+ regStr[destvar.location] + ((Label)n.f0.choice).f0.tokenImage + "\n");
	      }
    	  
      }
      else{
    	  switch(n.f0.which){
    	  case 0:
	    	  Temp tm = (Temp) n.f0.choice;
	    	  RangePair var = currproc.ranges.get(Integer.parseInt(tm.f1.f0.tokenImage));
	    	  if(var.isReg){
	    		  emit("astore spilledarg " + destvar.location + regStr[var.location]);
	    	  }
	    	  else{
	    		  emit("aload v0 spilledarg " + var.location);
	    		  emit("astore spilledarg " + destvar.location + " v0");
	    	  }
	    	  break;
    	  case 1:
	    	  IntegerLiteral il = (IntegerLiteral) n.f0.choice;
	    	  emit("move v0 " + il.f0.tokenImage);
	    	  emit("astore spilledarg " + destvar.location + " v0");
	    	  break;
    	  case 2:
	    	  emit("move v0 "+ ((Label)n.f0.choice).f0.tokenImage + "\n");
	    	  emit("astore spilledarg " + destvar.location + " v0");
    	  }
      }
      return null;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n) {
      R _ret=null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n) {
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n) {
	   //System.out.println(n.f0.tokenImage + "\n");
      R _ret=null;
      n.f0.accept(this);
      return _ret;
   }
   
   void emit(String s){
	   System.out.println(cap(s));
   }
   
   String cap(String s){
	   String[] sar = s.split("\\s+");
	   String ret = "";
	   for(String sub:sar){
		   if(!sub.matches("[vast]\\d")){
			   ret+=sub.toUpperCase();
		   }
		   else ret+=sub;
		   ret+=" ";
	   }
	   return ret;
   }

}
